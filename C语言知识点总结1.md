# 下标越界

**C语言不要求检查下标的范围**。当下标超出范围时，程序可能执行不可预知的行为，下标超出范围的原因之一是：忘记了 `n`元数组的索引是从0到 `n-1`。

```c++
int a[10], i; 
for(i = 1; i <= 10; i++)
    a[i] = 0;
```

对于某些编译器来说，这个表面上正确的 `for`语句可能产生一个无限循环，当变量 `i`的值变为10时，程序将数值0存储在 `a[10]`中，但是 `a[10]`这个元素并不存在，所以在元素 `a[9]`后数值0立刻进入内存，如果内存中变量 `i`放置在 `a[9]`的后边，那么变量 `i`将会被重置为0，进而导致循环重新开始。

# 数组初始化

```c++
int a[10] = {1,2,3,4,5,6,7,8,9,10};

//如果初始化式比数组短，那么数组中剩余的元素赋值为0
int a[10] = {1,2,3,4,5,6};
//等同于{1,2,3,4,5,6, 0, 0, 0, 0}

int a[10] = {0};
//a[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

//如果给定了初始化表达式,可以省略数组的长度
int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```

# 对数组使用sizeof运算符

运算符 `sizeof`确定元素的字节数，如果数组 `a`有10个整数，那么 `sizeof(a)`通常为40。

用数组的大小除以数组元素的大小可以得到数组的长度

$sizeof(a)/sizeof(a[0])$

当需要数组长度时，可以采用如下这种形式

```c++
for(int i = 0; i < sizeof(a) / sizeof(a[0]); i++)
	a[i] = 0;
```

# 存储字符串字面值

C语言把字符串字面值作为**字符数组**来处理，**当C语言编译器在程序中遇到长度为 `n`的字符串字面量时，会为字符串字面量分配长度为 `n+1`的内存空间，这块空间将用来存储字符串字面值中的字符，以及一个用来标志字符串末尾的额外字符（空字符）**。空字符是一个所有位都为0的字节，因此用转义序列 `\0`来表示。

对于字符串字面值 `"abc"`是作为4个字符的数组来存储的——a，b，c，和 `\0`。

字符串字面值可以为空，字符串 `""`作为单独一个空字符来存储：`\0`。

**字符串字面值作为数组来存储，编译器会把它看成 `char*`类型的指针**。

> 试图改变字符串字面量会导致未定义的行为：
>
> char *p = "abc";
>
> *p = 'd';
>
> 改变字符串字面值可能会导致程序崩溃或运行不稳定

# 字符串变量

**C语言保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串**。

假设需要用一个变量来存储最多有80个字符的字符串，由于字符串在末尾处需要有空字符，将变量声明为含有81个字符的数组。

```c++
#define STR_LEN 80
...
char str[STR_LEN + 1];
```

> 当声明用于存放字符串的字符数组时，要始终保证数组的长度比字符串的长度多一个字符，这是因为C语言规定每个字符串都要以空字符串结尾，如果没有给空字符预留位置，可能会导致程序运行时出现不可预知的结果，因为C函数库中的函数假设字符串都是以空字符结束的。

**声明长度为STR_LEN+1的字符数组并不意味着它总是用于存放长度为STR_LEN的字符串，字符串的长度取决于空字符的位置，而不是取决于用于存放字符串的字符数组的长度，有STR_LEN+1个字符的数组可以存放多种长度的字符串，范围是从空字符串到长度为STR_LEN的字符串。**

# 初始化字符串变量

字符串变量可以在声明时进行初始化。

```c
char date1[8] = "June 14";
```

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7  |
| - | - | - | - | - | - | - | -- |
| J | u | n | e |   | 1 | 4 | \0 |

对于 `"June 14"`来说，C编译去会把它堪称时数组初始化式的缩写形式，实际上，可以写成

```c
char data1[8] = {'J', 'u', 'n', 'e', ' ', '1', '4', '\0'};
```

**如果初始化式太短以至于不能填满字符串变量，这种情况下， 编译器会添加空字符串**。

```c
char date2[9] = "June 14";
```

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7  | 8  |
| - | - | - | - | - | - | - | -- | -- |
| J | u | n | e |   | 1 | 4 | \0 | \0 |

C语言允许初始化表达式（不包含空字符）与变量有完全相同的长度：

```c
char date3[7] = "June 14";
```

没有给空字符留空间，所以编译器不会试图存储空字符；

| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| - | - | - | - | - | - | - |
| J | u | n | e |   | 1 | 4 |

> 如果正在计划对用来放置字符串的字符数组进行初始化，一定要确保数组的长度要长于初始化式的长度，否则，编译器将忽略空字符，这将使得数组无法作为字符串使用。

# 字符数组和字符指针

对于

```c
char date[] = "June 14";
char *date = "June 14";
```

前者声明为 `date`是一个数组，后者声明 `date`为一个指针。

这二者之间有很大的差别

* 在声明为数组时，就像任意数组元素一样，可以修改存储在 `date`中的字符，在声明为指针时，`date`指向字符串字面值，字符串字面值是不可以修改的。
* 在声明为数组时，`date`是数组名，在声明为指针时，`date`是变量，这个变量可以在程序执行期间指向其他字符串。

**如果希望可以修改字符串，那么就要建立字符数组来存储字符串，声明指针变量是不够的**。

# 数组型函数参数

当形参是一维数组时，可以不用说明数组的长度。

```c
int f(int a[]);
```

实际参数可以是元素类型正确的任何一维数组，但是，`f`函数并不知道数组的长度，如果需要数组的长度，必须把长度作为额外的参数提供出来。

如果形参是多维数组，声明参数时只能省略第一维的长度

```c
#define LEN 10
int sum_two(int a[][LEN], int n);
```

# 结构体相关知识

**对于数组来说，数组不能使用 `=`运算符进行复制，但是当结构体中含有数组时，对结构体进行 `=`运算，嵌在结构体内的数组可以复制**。

```c
struct { int a[10]; } a1, a2;
a1 = a2;
```

# 结构体类型

如果需要在程序中的不同位置声明变量，例如

```c
struct {
	int number;
	char name[NAME_LEN+1];
	int on_hand;
}part1;
```

并在另一处编写

```c
struct {
	int number;
	char name[NAME_LEN+1];
	int on_hand;
}part2;
```

立刻会出现问题，根据C语言的规则，`part1`和 `part2`不具有兼容的类型，因此不能把 `part1`赋值给 `part2`。

**解决这样的问题，需要定义表示结构体类型的名字**。

# 结构标记的声明

```c
struct part{
	int number;
	char name[NAME_LEN + 1];
	int on_hand;
};
```

创建了标记 `part`，就可以用来声明变量了，

```c
struct part part1, part2;
```

**所有声明为struct part类型的结构彼此之间是兼容的。**

# volatile类型限定符

在某些计算机中，一部分内存空间是“易变”的，保存在这种内存空间的值可能会在程序运行期间发生改变，即使程序自身并未试图存放新值，例如，一些内存空间可能被用于保存直接来自输入设备的数据。

`volatile`类型限定符可以通知编译器，程序中的某些数据是“易变”的，`volatile`限定符通常使用在用于指向**易变内存空间**的指针的声明中。

```c
volatile BYTE *p;
```

假设指针 `p`指向的内存空间用于存放用户通过键盘输入的最近一个字符，这个内存空间是易变的，每次用户输入一个新字符，这里的值都会发生改变。

使用下面的循环获取键盘输入的字符，并将它们存入一个缓冲区数组中。

```c
while(缓冲区未满)
{
	//等待输入;
	buffer[i] = *p;
	if(buffer[i++] == '\n')
		break;
}
```

编译器在进行较高级别的优化时，会注意到这个循环既没有改变 `p`，也没有改变 `*p`，因此编译器可能会对程序进行优化，使得 `*p`只被取一次；

```c
//在寄存器中存储*p
while(缓冲区未满)
{
	//等待输入
	buffer[i] = 存储在寄存器中的值;
	if(buffer[i++] == '\n')
		break;
}
```

优化后的程序会不断复制同一个字符来填满缓冲区，这并不是我们想要的结果，将 `p`声明成指向易变的数据的指针可以避免这一问题的发生，**volatile限定符会通知编译器，指针p每一次都必须从内存中重新取值。**

# register存储类型

**声明变量具有 `register`存储类型，要求编译器把变量存储在寄存器中，而不是像其他变量一样保留在内存中，指明变量的存储类型是register是一种请求，而不是命令，编译器可以选择把register型变量存储在内存中**。

`register`存储类型只对声明在块内的变量有效。

**由于寄存器没有地址，所以对register变量使用取地址运算符&是非法的，即使编译器选择把变量存储在内存中。**

`register`存储类型最好用于需要频繁进行访问或更新的变量，例如，在 `for`语句中的循环控制变量就比较适合声明为 `register`。

```c
int sum_array(int a[], int n)
{
	register int i;
	int sum = 0;
	for(i =  0; i < n; i++)
		sum += a[i];
	return sum
}
```

# 宏定义

简单的宏定义：

```c
#define 标识符 替换列表

#define STE_LEN 	80
#define TRUE		1
#define FALSE		0
#define PI		3.14
#define CR		'\r'
#define EOS		'\0'
```

替换列表是一系列的预处理记号。

带参数的宏

```c
#define 标识符(x1,x2,...,xn) 替换列表

#define MAX(x,y) 	((x)>(y)?(x):(y))
#define IS_EVEN(n)	((n)%2==0)
#define PRINT_INT(n)	printf("%d\n", n)
#define TOUPPER(c) 	('a' <= (c) && (c) <= 'z'?(c)-'a'+'A':(c))
```

## 宏定义中的圆括号

* 如果宏的替换列表中有运算符，那么始终要将替换列表放在括号中。

```c
#define TWO_PI	(2*3.14159)
```

* 如果宏有参数，每个参数每次在替换列表中出现时都要放在圆括号中

```c
#define SCALE(x) ((x)*10)
```
